# Bitvector
bitvectorは以下の性質を満たすデータ構造である

- 全ての値が $0$ または $1$ であるような長さ $n$ の配列 `B` を $n + o(n)$ spaceで表現する。（簡潔データ構造）
- `rank`, `select`という2つの操作を定数時間で行うことができる
    - `rank(i,c)`...`B`において`[0, i)`の中の`c`の個数を求める
    - `select(j,c)`...`B`において、`j`番目に出現する`c`の位置を求める
- $O(n)$ timeで構築可能である。

bitvectorの`rank`を実現する手法としては、定数回の再帰的な呼び出しを利用して部分問題を固定サイズに抑える方法が用いられる。しかし、本実装では、64bitごとに`rank`を前計算で記録し、`rank`呼び出し時はその結果と端数のbitに対する`popcount`を組み合わせて計算している。そのため、`rank`の呼び出しは定数時間であるものの、空間計算量は $O(n)$ となっており、簡潔データ構造ではなく、コンパクトデータ構造となっている。

`select`については、定数時間で実行する方法を実装できておらず、`rank`呼び出しと二分探索を組み合わせた $O(\lg n)$ timeの実装となっている。実用上は十分に速く動作するが、定数時間による実装は今後の課題とする。

# Wavelet Tree
bitvectorは、2値配列を対象としたものであるが、wavelet treeはこれを任意の値に拡張したものである。配列の値が葉と対応するような完全二分木を考え、それぞれの中間ノードは部分木の表現する範囲と対応する。それぞれのノードはbitvectorを保持しており、それらを利用して、任意の値を持つ配列に対する`rank`などの操作を効率的に実現する。

実装において、以下の関数をサポートした。ただし、$\sigma$ は文字の種類数を表す。
- `access(i)`: `i`番目の要素を $O(\lg \sigma)$ timeで取得する
- `rank(i,c)`: `[0, i)` における `c` の出現回数を $O(\lg \sigma)$ timeで数える
- `range_count(i, j, lower, upper)`: 配列内の `[i, j)` の範囲に含まれる位置うち、その値が `[lower, upper)` に含まれる値の個数を $O(\lg \sigma)$ で数える
- `range_list(i, j, lower, upper)`: 配列内の `[i, j)` の範囲に含まれる位置うち、その値が `[lower, upper)` に含まれる値の集合を $O(\lg \sigma + k)$ で計算する。 $k$ は計算した集合のサイズである。
- `freq(i, j, c)`: `[i, j)` における `c` の出現回数を $O(\lg \sigma)$ で数える
- `is_range_unary(i, j)`: `[i, j)` の範囲にある値が単一であるかを $O(\lg \sigma)$ で調べる。

後日追加予定の関数
- `select(j, c)`...`B`において、`j`番目に出現する`c`の位置を求める

# Wavelet Matrix
後日追加予定

# 参考文献
Genome-Scale Algorithm Design 2nd edition